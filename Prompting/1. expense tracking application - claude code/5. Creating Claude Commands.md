## What are Claude Code Commands?

While claude.md provides global context for every interaction, commands deliver **targeted context and process for specific, repeatable tasks**. Think of commands as specialized instruction sets that give Claude Code exactly what it needs to know for particular workflows - without overwhelming it with irrelevant information.

## The TARGETED Framework for Command Design

Use this acronym to create effective commands:

- **T**ask-Specific Instructions
- **A**rguments and Placeholders
- **R**eusable Process Steps
- **G**uided Examples and References
- **E**xplicit Output Requirements
- **T**emplate-Based Naming
- **E**rror Handling and Edge Cases
- **D**ocumentation and Context

## Core Principles

### 1. Right Context at the Right Time

Commands solve the "400-page manual" problem by providing only the relevant context needed for a specific task, avoiding information overload.

### 2. Reusable Consistency

Commands ensure the same high-quality process is followed every time a task is performed, scaling your best practices across your AI labor.

### 3. Template-Driven Automation

Use placeholders and templates to make commands flexible while maintaining structure and naming conventions.

## Command Structure and Location

Commands are stored as markdown files in .claude/commands/ directory:

- **Project-specific**: .claude/commands/ (versioned with your project)
- **Global commands**: ~/.claude/commands/ (available across all projects)

# Command Management Tips

## Organization Strategies

- **By Function**: plan-feature.md, impl-api.md, test-unit.md, deploy-prod.md, ...
- **By Domain**: auth-login.md, user-profile.md, payment-process.md, order-create.md, ...
- **By Role**: dev-review.md, qa-automation.md, ops-deploy.md, pm-requirements.md, ...

## Version Control

- Store project commands in .claude/commands/ for team sharing
- Use descriptive commit messages when updating commands
- Review command changes as part of code review process

## Command Evolution

- Regularly review and update commands based on team feedback
- Archive outdated commands rather than deleting them
- Document command changes in project changelog

Commands transform Claude Code from a general assistant into a specialized team member with deep knowledge of your specific workflows. They ensure consistent, high-quality execution of repetitive tasks while providing the targeted context needed for complex operations.

# Examples of Commands

These commands are not meant to be used "as-is". You should take them and adapt them for your project. The goal is to provide inspiration for what a command might look like, not what it should look like. The best commands will be customized to your specific project.

## Example 1: Code Review Command

**File**: .claude/commands/code-review.md

```
# Code Review Command

Carefully perform a comprehensive code review of $ARGUMENTS.

## Review Standards
Examples of excellent code that you should match the design/style/conventions of:
- `src/components/UserProfile/UserProfile.tsx` (React components)
- `src/utils/dataValidation.ts` (utility functions)
- `src/hooks/useUserData.ts` (custom hooks)

## Process
1. **First**: Read the example files above to understand our design patterns, naming conventions, and code style
2. **Second**: Analyze $ARGUMENTS against these standards
3. **Third**: Create detailed critique covering:
   - Code structure and organization
   - Adherence to established patterns
   - Performance considerations
   - Security implications
   - Maintainability concerns
   - Test coverage gaps

## Output Requirements
- Save review as `ai-code-reviews/{filename}.review.md` for each file reviewed
- Include specific line references for issues
- Provide concrete suggestions for improvements
- Rate overall quality: Excellent/Good/Needs Improvement/Poor
- Estimate refactoring effort: Low/Medium/High

## Review Checklist
- Follows project naming conventions
- Proper error handling implemented
- No hardcoded values, secrets, or magic numbers
- Appropriate comments and documentation
- Follows existing design principles and consistent with exemplars
- No obvious security vulnerabilities
- Performance optimizations considered
```

## Example 2: API Test

**File**: .claude/commands/api-test

```
# API Testing Command

Create comprehensive API tests for: $ARGUMENTS

## Testing Strategy
Test the following API endpoints and scenarios based on $ARGUMENTS:

1. **Happy Path Testing**:
   - Valid request formats
   - Expected response structures
   - Proper HTTP status codes

2. **Error Handling Testing**:
   - Invalid request payloads
   - Authentication failures
   - Authorization edge cases
   - Rate limiting scenarios

3. **Edge Cases**:
   - Boundary value testing
   - Large payload handling
   - Concurrent request handling
   - Network timeout scenarios

## Test Structure Template
Create tests in `/tests/api/{endpoint-name}.test.ts`:

```typescript
describe('{Endpoint Name} API', () => {
  describe('POST /{endpoint}', () => {
    it('should create {resource} with valid data', async () => {
      // Test implementation
    });
    
    it('should return 400 for invalid data', async () => {
      // Test implementation
    });
    
    it('should require authentication', async () => {
      // Test implementation
    });
  });
  
  describe('GET /{endpoint}', () => {
    // Additional test cases
  });
});
```